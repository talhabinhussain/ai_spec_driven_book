"use strict";(self.webpackChunkai_native_book=self.webpackChunkai_native_book||[]).push([[615],{7419:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-4-vla/chapter-4-5-action-primitives","title":"Chapter 4.5: Action Primitives and Execution","description":"Overview","source":"@site/docs/module-4-vla/chapter-4-5-action-primitives.mdx","sourceDirName":"module-4-vla","slug":"/module-4-vla/chapter-4-5-action-primitives","permalink":"/ai_spec_driven_book/docs/module-4-vla/chapter-4-5-action-primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/talhabinhussain/ai_spec_driven_book/tree/main/docs/module-4-vla/chapter-4-5-action-primitives.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4.4: Vision-Language Integration","permalink":"/ai_spec_driven_book/docs/module-4-vla/chapter-4-4-vision-language"},"next":{"title":"Chapter 4.6: Building Conversational Robots","permalink":"/ai_spec_driven_book/docs/module-4-vla/chapter-4-6-conversational-robots"}}');var a=t(4848),o=t(8453);const r={sidebar_position:6},s="Chapter 4.5: Action Primitives and Execution",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Understanding Action Primitives",id:"understanding-action-primitives",level:2},{value:"Characteristics of Good Action Primitives",id:"characteristics-of-good-action-primitives",level:3},{value:"Defining Action Primitives",id:"defining-action-primitives",level:2},{value:"Navigation Action Primitives",id:"navigation-action-primitives",level:2},{value:"Manipulation Action Primitives",id:"manipulation-action-primitives",level:2},{value:"Composite Action Primitives",id:"composite-action-primitives",level:2},{value:"Action Execution Monitoring",id:"action-execution-monitoring",level:2},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Safety and Verification",id:"safety-and-verification",level:2},{value:"Practical Example: Complete VLA Action System",id:"practical-example-complete-vla-action-system",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Modularity",id:"1-modularity",level:3},{value:"2. Safety First",id:"2-safety-first",level:3},{value:"3. Robustness",id:"3-robustness",level:3},{value:"4. Performance",id:"4-performance",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-45-action-primitives-and-execution",children:"Chapter 4.5: Action Primitives and Execution"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Action primitives form the bridge between high-level plans generated by language models and low-level robot control. This chapter explores how to define, implement, and execute robot actions that can be triggered by VLA systems. You'll learn to create robust action primitives that handle real-world execution challenges, error recovery, and safety considerations while maintaining the connection to natural language planning."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-action-primitives",children:"Understanding Action Primitives"}),"\n",(0,a.jsx)(n.p,{children:"Action primitives are fundamental robot behaviors that can be composed into complex tasks. They represent the vocabulary of actions that a robot can perform, from simple movements to complex manipulation sequences."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph LR\n    A[High-Level Plan] --\x3e B[Action Sequence]\n    B --\x3e C[Action Primitives]\n    C --\x3e D[Low-Level Control]\n    D --\x3e E[Robot Execution]\n    E --\x3e F[Feedback Loop]\n    F --\x3e A\n"})}),"\n",(0,a.jsx)(n.h3,{id:"characteristics-of-good-action-primitives",children:"Characteristics of Good Action Primitives"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Composable"}),": Can be combined to form complex behaviors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameterizable"}),": Accept configurable parameters for flexibility"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Verifiable"}),": Include success/failure criteria"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Recoverable"}),": Have built-in error handling and recovery"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safe"}),": Include safety checks and constraints"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"defining-action-primitives",children:"Defining Action Primitives"}),"\n",(0,a.jsx)(n.p,{children:"Let's define a comprehensive set of action primitives for a humanoid robot:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Pose, Point, Quaternion\nfrom sensor_msgs.msg import JointState\nfrom your_interfaces.action import NavigateTo, ManipulateObject, Speak, Wait  # Custom action definitions\n\nclass ActionPrimitiveManager(Node):\n    def __init__(self):\n        super().__init__('action_primitive_manager')\n\n        # Initialize action primitives\n        self.action_primitives = {\n            'navigate_to': NavigateToPrimitive(self),\n            'manipulate_object': ManipulateObjectPrimitive(self),\n            'speak': SpeakPrimitive(self),\n            'wait': WaitPrimitive(self),\n            'open_gripper': OpenGripperPrimitive(self),\n            'close_gripper': CloseGripperPrimitive(self),\n            'move_arm': MoveArmPrimitive(self),\n            'turn_head': TurnHeadPrimitive(self),\n            'detect_object': DetectObjectPrimitive(self),\n            'grasp_object': GraspObjectPrimitive(self)\n        }\n\n        # Publishers for low-level control\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.joint_pub = self.create_publisher(JointState, '/joint_commands', 10)\n        self.speech_pub = self.create_publisher(String, '/speech_commands', 10)\n\n        # Service clients for perception\n        self.perception_client = self.create_client(PerceptionService, '/object_detection')\n\n        self.get_logger().info(\"Action primitive manager initialized\")\n\n    def execute_action(self, action_name, parameters):\n        \"\"\"\n        Execute a specific action primitive with given parameters\n        \"\"\"\n        if action_name in self.action_primitives:\n            primitive = self.action_primitives[action_name]\n            return primitive.execute(parameters)\n        else:\n            self.get_logger().error(f\"Unknown action primitive: {action_name}\")\n            return False\n"})}),"\n",(0,a.jsx)(n.h2,{id:"navigation-action-primitives",children:"Navigation Action Primitives"}),"\n",(0,a.jsx)(n.p,{children:"Navigation is one of the most fundamental action primitives for mobile robots:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from nav2_msgs.action import NavigateToPose\nimport rclpy.action\n\nclass NavigateToPrimitive:\n    def __init__(self, node):\n        self.node = node\n        self.nav_client = rclpy.action.ActionClient(\n            node, NavigateToPose, 'navigate_to_pose'\n        )\n\n    async def execute(self, parameters):\n        \"\"\"\n        Execute navigation action with safety checks\n        \"\"\"\n        # Validate parameters\n        if 'location' not in parameters and 'pose' not in parameters:\n            self.node.get_logger().error(\"Navigation requires location or pose parameter\")\n            return False\n\n        # Get target pose\n        if 'location' in parameters:\n            pose = self.get_pose_for_location(parameters['location'])\n        else:\n            pose = parameters['pose']\n\n        # Safety checks\n        if not self.is_navigation_safe(pose):\n            self.node.get_logger().warn(\"Navigation to location is unsafe\")\n            return False\n\n        # Create navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.node.get_clock().now().to_msg()\n        goal_msg.pose.pose = pose\n\n        # Wait for server\n        self.nav_client.wait_for_server()\n\n        # Send goal\n        goal_handle = await self.nav_client.send_goal_async(goal_msg)\n\n        if not goal_handle.accepted:\n            self.node.get_logger().error(\"Navigation goal was rejected\")\n            return False\n\n        # Wait for result\n        result = await goal_handle.get_result_async()\n\n        success = result.result.status == 3  # SUCCEEDED\n        if success:\n            self.node.get_logger().info(f\"Successfully navigated to {parameters.get('location', 'pose')}\")\n        else:\n            self.node.get_logger().warn(f\"Navigation failed to {parameters.get('location', 'pose')}\")\n\n        return success\n\n    def get_pose_for_location(self, location_name):\n        \"\"\"\n        Convert location name to pose coordinates\n        \"\"\"\n        # This would typically come from a map/waypoint database\n        location_poses = {\n            'kitchen': Pose(position=Point(x=1.0, y=0.0, z=0.0),\n                           orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)),\n            'living_room': Pose(position=Point(x=0.0, y=1.0, z=0.0),\n                              orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)),\n            'bedroom': Pose(position=Point(x=2.0, y=1.0, z=0.0),\n                          orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)),\n            'home_base': Pose(position=Point(x=0.0, y=0.0, z=0.0),\n                             orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0))\n        }\n\n        if location_name in location_poses:\n            return location_poses[location_name]\n        else:\n            self.node.get_logger().warn(f\"Unknown location: {location_name}\")\n            return None\n\n    def is_navigation_safe(self, pose):\n        \"\"\"\n        Check if navigation to pose is safe\n        \"\"\"\n        # Check if pose is reachable\n        # Check for obstacles\n        # Check robot battery level\n        # Check for dynamic obstacles\n\n        # For now, assume it's safe\n        return True\n"})}),"\n",(0,a.jsx)(n.h2,{id:"manipulation-action-primitives",children:"Manipulation Action Primitives"}),"\n",(0,a.jsx)(n.p,{children:"Manipulation primitives handle object interaction and manipulation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass ManipulateObjectPrimitive:\n    def __init__(self, node):\n        self.node = node\n        self.trajectory_client = rclpy.action.ActionClient(\n            node, FollowJointTrajectory, \'joint_trajectory_controller/follow_joint_trajectory\'\n        )\n        self.gripper_client = rclpy.action.ActionClient(\n            node, FollowJointTrajectory, \'gripper_controller/follow_joint_trajectory\'\n        )\n\n    async def execute(self, parameters):\n        """\n        Execute manipulation action with object detection and grasping\n        """\n        action = parameters.get(\'action\', \'grasp\')\n        object_name = parameters.get(\'object\', None)\n        location = parameters.get(\'location\', None)\n\n        if action == \'grasp\':\n            return await self.grasp_object(object_name, location)\n        elif action == \'place\':\n            return await self.place_object(location)\n        elif action == \'open\':\n            return await self.open_object(object_name)\n        elif action == \'close\':\n            return await self.close_object(object_name)\n        else:\n            self.node.get_logger().error(f"Unknown manipulation action: {action}")\n            return False\n\n    async def grasp_object(self, object_name, location):\n        """\n        Execute grasping sequence\n        """\n        # 1. Navigate near object\n        if location:\n            nav_params = {\'location\': location}\n            nav_success = await self.node.action_primitives[\'navigate_to\'].execute(nav_params)\n            if not nav_success:\n                return False\n\n        # 2. Detect object\n        detect_params = {\'object\': object_name, \'search\': True}\n        object_pose = await self.detect_object(object_name)\n        if object_pose is None:\n            self.node.get_logger().warn(f"Could not find object: {object_name}")\n            return False\n\n        # 3. Position arm for grasping\n        approach_pose = self.calculate_approach_pose(object_pose)\n        arm_success = await self.move_arm_to_pose(approach_pose)\n        if not arm_success:\n            return False\n\n        # 4. Grasp the object\n        gripper_params = {\'command\': \'close\', \'force\': 50}\n        gripper_success = await self.control_gripper(gripper_params)\n\n        if gripper_success:\n            self.node.get_logger().info(f"Successfully grasped {object_name}")\n            return True\n        else:\n            self.node.get_logger().warn(f"Failed to grasp {object_name}")\n            return False\n\n    async def place_object(self, location):\n        """\n        Place currently held object at location\n        """\n        # Check if robot is holding an object\n        if not self.is_holding_object():\n            self.node.get_logger().warn("Robot is not holding an object")\n            return False\n\n        # Navigate to placement location\n        nav_params = {\'location\': location}\n        nav_success = await self.node.action_primitives[\'navigate_to\'].execute(nav_params)\n        if not nav_success:\n            return False\n\n        # Position arm for placement\n        placement_pose = self.get_placement_pose(location)\n        arm_success = await self.move_arm_to_pose(placement_pose)\n        if not arm_success:\n            return False\n\n        # Release object\n        gripper_params = {\'command\': \'open\', \'force\': 0}\n        gripper_success = await self.control_gripper(gripper_params)\n\n        if gripper_success:\n            self.node.get_logger().info(f"Successfully placed object at {location}")\n            return True\n        else:\n            return False\n\n    async def detect_object(self, object_name):\n        """\n        Detect object in the environment\n        """\n        # This would call perception service\n        # For now, simulate object detection\n        self.node.get_logger().info(f"Detecting {object_name}")\n        # Simulate detection with some probability\n        import random\n        if random.random() > 0.3:  # 70% success rate\n            # Return simulated pose\n            pose = Pose(\n                position=Point(x=1.0, y=0.5, z=0.0),\n                orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)\n            )\n            return pose\n        return None\n\n    def calculate_approach_pose(self, object_pose):\n        """\n        Calculate approach pose for grasping\n        """\n        # Calculate approach position (slightly offset from object)\n        approach_pose = Pose()\n        approach_pose.position.x = object_pose.position.x - 0.1  # 10cm in front\n        approach_pose.position.y = object_pose.position.y\n        approach_pose.position.z = object_pose.position.z + 0.05  # Slightly above\n        approach_pose.orientation = object_pose.orientation\n        return approach_pose\n\n    async def move_arm_to_pose(self, pose):\n        """\n        Move robot arm to specified pose\n        """\n        # Convert pose to joint trajectory\n        # This would use inverse kinematics\n        trajectory = self.calculate_arm_trajectory(pose)\n\n        goal_msg = FollowJointTrajectory.Goal()\n        goal_msg.trajectory = trajectory\n\n        self.trajectory_client.wait_for_server()\n        goal_handle = await self.trajectory_client.send_goal_async(goal_msg)\n\n        if not goal_handle.accepted:\n            return False\n\n        result = await goal_handle.get_result_async()\n        return result.result.error_code == 0  # SUCCESS\n\n    def calculate_arm_trajectory(self, pose):\n        """\n        Calculate joint trajectory for reaching pose\n        """\n        # This would use inverse kinematics solver\n        # For now, return a simple trajectory\n        trajectory = JointTrajectory()\n        trajectory.joint_names = [\'joint1\', \'joint2\', \'joint3\', \'joint4\', \'joint5\', \'joint6\']\n\n        point = JointTrajectoryPoint()\n        point.positions = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Placeholder\n        point.time_from_start.sec = 2\n\n        trajectory.points = [point]\n        return trajectory\n\n    async def control_gripper(self, parameters):\n        """\n        Control gripper with specified parameters\n        """\n        command = parameters.get(\'command\', \'open\')\n        force = parameters.get(\'force\', 25)\n\n        # Create gripper trajectory\n        trajectory = JointTrajectory()\n        trajectory.joint_names = [\'gripper_joint\']\n\n        point = JointTrajectoryPoint()\n        if command == \'open\':\n            point.positions = [0.05]  # Fully open\n        else:  # close\n            point.positions = [0.01]  # Closed position (adjusted for object)\n\n        point.effort = [force]\n        point.time_from_start.sec = 1\n\n        trajectory.points = [point]\n\n        goal_msg = FollowJointTrajectory.Goal()\n        goal_msg.trajectory = trajectory\n\n        self.gripper_client.wait_for_server()\n        goal_handle = await self.gripper_client.send_goal_async(goal_msg)\n\n        if not goal_handle.accepted:\n            return False\n\n        result = await goal_handle.get_result_async()\n        return result.result.error_code == 0  # SUCCESS\n\n    def is_holding_object(self):\n        """\n        Check if robot is currently holding an object\n        """\n        # This would check gripper force sensors or other indicators\n        # For simulation, return random result\n        import random\n        return random.choice([True, False])\n'})}),"\n",(0,a.jsx)(n.h2,{id:"composite-action-primitives",children:"Composite Action Primitives"}),"\n",(0,a.jsx)(n.p,{children:"More complex actions can be built by combining basic primitives:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class CompositeActionPrimitive:\n    def __init__(self, node):\n        self.node = node\n\n    async def execute(self, parameters):\n        \"\"\"\n        Execute a sequence of actions as a single primitive\n        \"\"\"\n        action_sequence = parameters.get('sequence', [])\n        on_failure = parameters.get('on_failure', 'stop')\n\n        for action in action_sequence:\n            action_name = action['action']\n            action_params = action.get('parameters', {})\n\n            success = await self.node.execute_action(action_name, action_params)\n\n            if not success:\n                self.node.get_logger().warn(f\"Action failed: {action_name}\")\n\n                if on_failure == 'stop':\n                    return False\n                elif on_failure == 'continue':\n                    continue\n                elif on_failure == 'retry':\n                    # Retry with modified parameters\n                    retry_success = await self.node.execute_action(action_name, action_params)\n                    if not retry_success:\n                        return False\n\n        return True\n\nclass FetchObjectPrimitive(CompositeActionPrimitive):\n    def __init__(self, node):\n        super().__init__(node)\n\n    async def execute(self, parameters):\n        \"\"\"\n        Complete sequence: navigate to object -> detect -> grasp -> return\n        \"\"\"\n        object_name = parameters['object']\n        return_location = parameters.get('return_to', 'home_base')\n\n        # Sequence of actions\n        action_sequence = [\n            {\n                'action': 'navigate_to',\n                'parameters': {'location': f'location_of_{object_name}'}\n            },\n            {\n                'action': 'detect_object',\n                'parameters': {'object': object_name}\n            },\n            {\n                'action': 'manipulate_object',\n                'parameters': {'action': 'grasp', 'object': object_name}\n            },\n            {\n                'action': 'navigate_to',\n                'parameters': {'location': return_location}\n            }\n        ]\n\n        sequence_params = {\n            'sequence': action_sequence,\n            'on_failure': 'stop'\n        }\n\n        return await super().execute(sequence_params)\n\nclass DeliverObjectPrimitive(CompositeActionPrimitive):\n    def __init__(self, node):\n        super().__init__(node)\n\n    async def execute(self, parameters):\n        \"\"\"\n        Deliver object to specific location\n        \"\"\"\n        target_location = parameters['location']\n\n        action_sequence = [\n            {\n                'action': 'navigate_to',\n                'parameters': {'location': target_location}\n            },\n            {\n                'action': 'manipulate_object',\n                'parameters': {'action': 'place', 'location': target_location}\n            }\n        ]\n\n        sequence_params = {\n            'sequence': action_sequence,\n            'on_failure': 'retry'\n        }\n\n        return await super().execute(sequence_params)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"action-execution-monitoring",children:"Action Execution Monitoring"}),"\n",(0,a.jsx)(n.p,{children:"Robust action execution requires monitoring and feedback:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class ActionExecutionMonitor:\n    def __init__(self, node):\n        self.node = node\n        self.active_actions = {}\n        self.action_history = []\n\n    def start_action_monitoring(self, action_id, action_name, parameters):\n        \"\"\"\n        Start monitoring an action\n        \"\"\"\n        import time\n        self.active_actions[action_id] = {\n            'name': action_name,\n            'parameters': parameters,\n            'start_time': time.time(),\n            'status': 'running',\n            'progress': 0.0\n        }\n\n    def update_action_progress(self, action_id, progress, details=None):\n        \"\"\"\n        Update progress of a running action\n        \"\"\"\n        if action_id in self.active_actions:\n            self.active_actions[action_id]['progress'] = progress\n            if details:\n                self.active_actions[action_id]['details'] = details\n\n    def complete_action(self, action_id, success, result=None):\n        \"\"\"\n        Mark action as completed\n        \"\"\"\n        if action_id in self.active_actions:\n            action_info = self.active_actions[action_id]\n            action_info['status'] = 'completed' if success else 'failed'\n            action_info['end_time'] = time.time()\n            action_info['duration'] = action_info['end_time'] - action_info['start_time']\n            action_info['result'] = result\n\n            # Move to history\n            self.action_history.append(action_info.copy())\n            del self.active_actions[action_id]\n\n            return action_info\n        return None\n\n    def get_action_status(self, action_id):\n        \"\"\"\n        Get status of a specific action\n        \"\"\"\n        if action_id in self.active_actions:\n            return self.active_actions[action_id]\n        # Check history if not active\n        for action in reversed(self.action_history):\n            if action.get('id') == action_id:\n                return action\n        return None\n\n    def cancel_action(self, action_id):\n        \"\"\"\n        Cancel a running action\n        \"\"\"\n        if action_id in self.active_actions:\n            self.active_actions[action_id]['status'] = 'cancelled'\n            action_info = self.active_actions[action_id]\n            self.action_history.append(action_info.copy())\n            del self.active_actions[action_id]\n            return True\n        return False\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,a.jsx)(n.p,{children:"Comprehensive error handling is essential for robust action execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class RobustActionPrimitive:\n    def __init__(self, node):\n        self.node = node\n        self.monitor = ActionExecutionMonitor(node)\n\n    async def execute_with_recovery(self, action_name, parameters):\n        """\n        Execute action with built-in recovery mechanisms\n        """\n        max_retries = parameters.get(\'max_retries\', 3)\n        recovery_strategies = parameters.get(\'recovery_strategies\', [\'retry\', \'alternative\', \'abort\'])\n\n        for attempt in range(max_retries + 1):\n            if attempt > 0:\n                self.node.get_logger().info(f"Retry attempt {attempt} for {action_name}")\n\n            try:\n                # Generate unique action ID\n                action_id = f"{action_name}_{int(time.time() * 1000)}"\n\n                # Start monitoring\n                self.monitor.start_action_monitoring(action_id, action_name, parameters)\n\n                # Execute action\n                success = await self.execute_primitive(action_name, parameters)\n\n                # Complete monitoring\n                self.monitor.complete_action(action_id, success)\n\n                if success:\n                    return True\n\n            except Exception as e:\n                self.node.get_logger().error(f"Action {action_name} failed with exception: {e}")\n                self.monitor.complete_action(action_id, False, str(e))\n\n            # If last attempt, try recovery strategies\n            if attempt == max_retries:\n                recovery_success = await self.attempt_recovery(action_name, parameters, recovery_strategies)\n                if recovery_success:\n                    return True\n\n        return False\n\n    async def execute_primitive(self, action_name, parameters):\n        """\n        Execute the actual primitive action\n        """\n        if action_name in self.node.action_primitives:\n            return await self.node.action_primitives[action_name].execute(parameters)\n        else:\n            return False\n\n    async def attempt_recovery(self, action_name, parameters, strategies):\n        """\n        Attempt various recovery strategies\n        """\n        for strategy in strategies:\n            if strategy == \'retry\':\n                # Already tried max retries, skip\n                continue\n            elif strategy == \'alternative\':\n                # Try alternative approach\n                alt_success = await self.try_alternative_approach(action_name, parameters)\n                if alt_success:\n                    return True\n            elif strategy == \'abort\':\n                # Abort and return failure\n                return False\n            elif strategy == \'human_assistance\':\n                # Request human assistance\n                await self.request_human_assistance(action_name, parameters)\n                return False\n\n        return False\n\n    async def try_alternative_approach(self, action_name, parameters):\n        """\n        Try an alternative approach to the same goal\n        """\n        if action_name == \'navigate_to\':\n            # Try alternative navigation method\n            return await self.try_alternative_navigation(parameters)\n        elif action_name == \'grasp_object\':\n            # Try different grasping approach\n            return await self.try_different_grasp(parameters)\n        # Add more alternative strategies as needed\n        return False\n\n    async def try_alternative_navigation(self, parameters):\n        """\n        Try alternative navigation method\n        """\n        # Try global planner alternative\n        # Try different navigation parameters\n        # Use different costmap\n        self.node.get_logger().info("Trying alternative navigation approach")\n        return False  # Placeholder\n\n    async def try_different_grasp(self, parameters):\n        """\n        Try different grasping approach\n        """\n        # Try different grasp angles\n        # Try different gripper forces\n        # Try different approach poses\n        self.node.get_logger().info("Trying different grasp approach")\n        return False  # Placeholder\n\n    async def request_human_assistance(self, action_name, parameters):\n        """\n        Request human assistance for the failed action\n        """\n        assistance_msg = String()\n        assistance_msg.data = f"NEED_ASSISTANCE: {action_name} failed with parameters {parameters}"\n        self.node.speech_pub.publish(assistance_msg)\n        self.node.get_logger().info(f"Requested human assistance for {action_name}")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"safety-and-verification",children:"Safety and Verification"}),"\n",(0,a.jsx)(n.p,{children:"Safety checks should be integrated into every action primitive:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class SafeActionPrimitive:\n    def __init__(self, node):\n        self.node = node\n        self.safety_limits = {\n            \'max_velocity\': 0.5,  # m/s\n            \'max_acceleration\': 1.0,  # m/s\xb2\n            \'max_gripper_force\': 100,  # N\n            \'min_distance_to_obstacle\': 0.3,  # m\n            \'max_joint_limits\': [2.0, 1.5, 2.0, 1.5, 2.0, 1.5]  # rad\n        }\n\n    async def execute_with_safety(self, action_name, parameters):\n        """\n        Execute action with safety checks\n        """\n        # Pre-execution safety checks\n        if not await self.pre_execution_check(action_name, parameters):\n            return False\n\n        # Execute action\n        success = await self.execute_primitive(action_name, parameters)\n\n        # Post-execution verification\n        if success:\n            success = await self.post_execution_verification(action_name, parameters)\n\n        return success\n\n    async def pre_execution_check(self, action_name, parameters):\n        """\n        Perform safety checks before executing action\n        """\n        # Check robot state\n        if not self.is_robot_ready():\n            self.node.get_logger().error("Robot is not ready for action execution")\n            return False\n\n        # Check battery level\n        if not self.is_battery_sufficient():\n            self.node.get_logger().error("Insufficient battery for action execution")\n            return False\n\n        # Check environmental constraints\n        if action_name == \'navigate_to\':\n            if not await self.is_navigation_path_safe(parameters):\n                return False\n\n        # Check action-specific constraints\n        if action_name == \'manipulate_object\':\n            if not self.is_manipulation_safe(parameters):\n                return False\n\n        return True\n\n    def is_robot_ready(self):\n        """\n        Check if robot is in ready state\n        """\n        # Check if robot is not in error state\n        # Check if all required subsystems are active\n        # Check if robot is properly calibrated\n        return True\n\n    def is_battery_sufficient(self):\n        """\n        Check if battery level is sufficient\n        """\n        # In practice, this would check actual battery status\n        return True\n\n    async def is_navigation_path_safe(self, parameters):\n        """\n        Check if navigation path is safe\n        """\n        # Check for obstacles along path\n        # Check for dynamic obstacles\n        # Check if destination is navigable\n        return True\n\n    def is_manipulation_safe(self, parameters):\n        """\n        Check if manipulation action is safe\n        """\n        # Check if target object is safe to manipulate\n        # Check if gripper force limits are respected\n        # Check if arm will not collide with environment\n        return True\n\n    async def post_execution_verification(self, action_name, parameters):\n        """\n        Verify action was completed successfully\n        """\n        # Check if robot reached intended state\n        # Verify object manipulation was successful\n        # Check for any safety violations during execution\n\n        if action_name == \'navigate_to\':\n            return await self.verify_navigation_success(parameters)\n        elif action_name == \'manipulate_object\':\n            return await self.verify_manipulation_success(parameters)\n\n        return True\n\n    async def verify_navigation_success(self, parameters):\n        """\n        Verify navigation action was successful\n        """\n        # Check if robot is at target location\n        # Check if path was followed correctly\n        # Check if robot is in safe state after navigation\n        return True\n\n    async def verify_manipulation_success(self, parameters):\n        """\n        Verify manipulation action was successful\n        """\n        # Check if object is grasped\n        # Check gripper force sensors\n        # Check if arm is in expected configuration\n        return True\n'})}),"\n",(0,a.jsx)(n.h2,{id:"practical-example-complete-vla-action-system",children:"Practical Example: Complete VLA Action System"}),"\n",(0,a.jsx)(n.p,{children:"Let's build a complete example that integrates VLA with action primitives:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class VLAActionSystemNode(Node):\n    def __init__(self):\n        super().__init__('vla_action_system')\n\n        # Initialize all action primitives\n        self.action_manager = ActionPrimitiveManager(self)\n\n        # Add composite actions\n        self.action_manager.action_primitives['fetch_object'] = FetchObjectPrimitive(self)\n        self.action_manager.action_primitives['deliver_object'] = DeliverObjectPrimitive(self)\n\n        # VLA integration\n        self.plan_sub = self.create_subscription(String, 'action_plan', self.plan_callback, 10)\n        self.status_pub = self.create_publisher(String, 'action_status', 10)\n\n        # Action execution components\n        self.monitor = ActionExecutionMonitor(self)\n        self.safe_executor = SafeActionPrimitive(self)\n        self.robust_executor = RobustActionPrimitive(self)\n\n        self.get_logger().info(\"VLA Action System initialized\")\n\n    def plan_callback(self, msg):\n        \"\"\"\n        Process incoming action plans from VLA system\n        \"\"\"\n        import json\n        try:\n            plan_data = json.loads(msg.data)\n            self.execute_plan(plan_data)\n        except json.JSONDecodeError:\n            # If not JSON, treat as simple action\n            action_parts = msg.data.split(':')\n            if len(action_parts) >= 2:\n                action_name = action_parts[0]\n                parameters_str = ':'.join(action_parts[1:])\n\n                parameters = {}\n                # Parse parameters - this is simplified\n                try:\n                    parameters = json.loads(parameters_str)\n                except:\n                    parameters = {\"raw\": parameters_str}\n\n                self.execute_action_now(action_name, parameters)\n\n    async def execute_plan(self, plan_data):\n        \"\"\"\n        Execute a complete action plan\n        \"\"\"\n        plan = plan_data.get('plan', [])\n        action_sequence = plan_data.get('action_sequence', plan)\n\n        for step in action_sequence:\n            action_name = step.get('action')\n            parameters = step.get('parameters', {})\n            action_id = step.get('id', f\"action_{int(time.time())}\")\n\n            self.get_logger().info(f\"Executing action: {action_name} with params: {parameters}\")\n\n            # Execute action with safety and monitoring\n            success = await self.execute_action_now(action_name, parameters)\n\n            if not success:\n                self.get_logger().warn(f\"Action {action_name} failed\")\n\n                # Handle failure based on plan configuration\n                if step.get('on_failure', 'stop') == 'stop':\n                    self.get_logger().info(\"Stopping plan execution due to failure\")\n                    break\n                elif step.get('on_failure', 'stop') == 'continue':\n                    continue\n                elif step.get('on_failure', 'stop') == 'retry':\n                    success = await self.execute_action_now(action_name, parameters)\n                    if not success:\n                        self.get_logger().error(f\"Retry failed for {action_name}\")\n                        break\n\n        self.get_logger().info(\"Plan execution completed\")\n\n    async def execute_action_now(self, action_name, parameters):\n        \"\"\"\n        Execute action immediately with all safety checks\n        \"\"\"\n        try:\n            # Use robust execution with recovery\n            success = await self.robust_executor.execute_with_recovery(action_name, parameters)\n\n            # Publish status\n            status_msg = String()\n            status_msg.data = f\"action:{action_name}:{'success' if success else 'failed'}\"\n            self.status_pub.publish(status_msg)\n\n            return success\n        except Exception as e:\n            self.get_logger().error(f\"Error executing action {action_name}: {e}\")\n            return False\n\n    def execute_action_with_timeout(self, action_name, parameters, timeout=30.0):\n        \"\"\"\n        Execute action with timeout protection\n        \"\"\"\n        import asyncio\n        try:\n            # Execute with timeout\n            task = self.execute_action_now(action_name, parameters)\n            result = asyncio.wait_for(task, timeout=timeout)\n            return result\n        except asyncio.TimeoutError:\n            self.get_logger().error(f\"Action {action_name} timed out after {timeout}s\")\n            # Cancel the running action if possible\n            return False\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-modularity",children:"1. Modularity"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Design action primitives to be independent and reusable"}),"\n",(0,a.jsx)(n.li,{children:"Use consistent parameter formats across primitives"}),"\n",(0,a.jsx)(n.li,{children:"Separate concerns (navigation, manipulation, perception)"}),"\n",(0,a.jsx)(n.li,{children:"Implement proper error boundaries between primitives"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-safety-first",children:"2. Safety First"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Always perform pre-execution safety checks"}),"\n",(0,a.jsx)(n.li,{children:"Implement post-execution verification"}),"\n",(0,a.jsx)(n.li,{children:"Set appropriate limits and constraints"}),"\n",(0,a.jsx)(n.li,{children:"Include emergency stop mechanisms"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-robustness",children:"3. Robustness"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement comprehensive error handling"}),"\n",(0,a.jsx)(n.li,{children:"Use timeouts to prevent hanging actions"}),"\n",(0,a.jsx)(n.li,{children:"Include recovery strategies for common failures"}),"\n",(0,a.jsx)(n.li,{children:"Log all actions for debugging and analysis"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-performance",children:"4. Performance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Optimize action execution for real-time performance"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate action server configurations"}),"\n",(0,a.jsx)(n.li,{children:"Implement action caching where beneficial"}),"\n",(0,a.jsx)(n.li,{children:"Monitor resource usage during execution"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inadequate Error Handling"}),": Failing to handle all possible failure modes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safety Oversights"}),": Not implementing proper safety checks before execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Timeout Issues"}),": Actions that can hang indefinitely without timeout protection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Exhaustion"}),": Not managing memory and computation resources properly"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lack of Verification"}),": Not confirming actions completed successfully"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"In this chapter, you learned:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u2705 How to define and implement action primitives for robotic systems"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Navigation and manipulation primitive implementations"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Creating composite actions from basic primitives"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Action execution monitoring and feedback systems"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Error handling and recovery mechanisms"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Safety checks and verification procedures"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Building complete VLA action execution systems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Now that you understand action primitives and execution, let's explore how to build conversational interfaces that make human-robot interaction more natural and intuitive."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Continue to:"})," ",(0,a.jsx)(n.a,{href:"./chapter-4-6-conversational-robots",children:"Chapter 4.6: Building Conversational Robots \u2192"})]}),"\n",(0,a.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/Concepts/About-Actions.html",children:"ROS 2 Action Architecture"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://navigation.ros.org/",children:"Navigation2 Stack"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://ros-planning.github.io/moveit_tutorials/",children:"Manipulation in ROS"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://arxiv.org/abs/2304.12506",children:"Robot Action Languages"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://ieeexplore.ieee.org/document/9876543",children:"Human-Robot Interaction Guidelines"})}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);